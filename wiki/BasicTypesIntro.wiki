#summary Introduction to the Common C++ Types in the VM

= Introduction =

The Strongtalk virtual machine is a large, complex C++ program.  To manage that complexity, the VM design is based around the highly structured use of a number of core C++ classes and coding techniques, which you will see used over and over again in the code.  Much of this basic structure is inherited from the Self virtual machine design.  To understand the VM design, it is first necessary to understand the use of these core classes.

= Smalltalk vs. C++ objects =

First of all, we need to deal with a fundamental ambiguity: when we say object or class, are we talking about C++ objects/classes in the VM code, or are we talking about Smalltalk objects that the VM is simulating?  So it is necessary to be clear about the distinction.  In the Strongtalk VM, a fair amount of effort has been made to map Smalltalk objects into C++ objects, so that the VM can operate on the simulated objects in a natural and object-oriented way.

As you read try to understand why the VM classes are structured the way they are, try to keep in mind that there are a number of fundamental issues:

  * *Allocation* Smalltalk objects are always allocated in the garbage-collected heap, whereas C++ objects are generally allocated elsewhere, either on the C heap, the stack, or in one of a number special areas used by the VM.  Two of the most important are:
    * The *Resource Area*: temporary C++ objects that cannot be stack allocated but which are only needed until the end of the current VM operation are allocated in the Resource area, which is a special chunk of contiguous memory that is tail-allocated for very high allocation speed.  When the current VM operation completes, the end-pointer for the allocation area is simply reset to the beginning, instantly freeing all resource objects.   However, note that such objects will *not* have their destructors called, so destructors are not used for objects in the resource area.
    * The *Zone*: The zone is used to hold compiled code objects.
  * *Write Barrier*: Since Smalltalk objects are managed by a generational garbage collector that uses card-marking, all stores of Smalltalk references into Smalltalk object fields _must_ be recorded for the garbage collector.
  * *GC relocation*: care must be taken that VM references to objects on the garbage collected heap must not be maintained across a garbage collection, since they may be relocated, invalidating the reference.
  * *Dispatch*: Smalltalk objects have a different dispatch model and header format than C++ objects.  Because there is no vtable in the Smalltalk object header, C++ objects that map to Smalltalk objects cannot contain virtual functions.  This issue will be discussed more below. 

= Oop-s: Smalltalk Object References =

In Strongtalk VM terminology, an Oop (Object Oriented Pointer) is a *tagged* reference to a Smalltalk object.  